Bootstrap: localimage
From: itk.sif

%environment
    source /opt/env/samba.sh

%post
	set -eu
    # Ensure canonical env file exists (inherited from base, but harmless)
    mkdir -p /opt/env
    [ -f /opt/env/samba.sh ] || { echo "FATAL: /opt/env/samba.sh missing" >&2; exit 1; }

    # Append ANTs runtime env to the single canonical env file (ONCE)
    # IMPORTANT:
    #   - Do NOT redefine SAMBA_APPS_DIR here (base.def owns it)
    #   - Do NOT put build-control knobs (ANTS_REF/ANTS_TARGETS/SRC_ROOT) into runtime env
    if ! grep -q '^# ---- ANTs (stage: ants) ----$' /opt/env/samba.sh; then
        cat << 'EOF' >> /opt/env/samba.sh

# ---- ANTs (stage: ants) ----
# Base stage defines SAMBA_APPS_DIR. Derive everything from it (no overrides).
export ANTSPATH="${SAMBA_APPS_DIR}/ants/bin"
export ITK_DIR="/opt/itk/lib/cmake/ITK-5.3"
export PATH="${ANTSPATH}:${PATH}"
EOF
    fi

    # Make it available immediately during build, too
    . /opt/env/samba.sh


    # -- Paths/inputs (build-time only; do NOT write these into /opt/env/samba.sh) --
    # I'm ignoring this code: 
    #"${SAMBA_APPS_DIR:=/opt/samba}"   # base.def should set this, but safe fallback for build
    SRC_ROOT="/opt/src"

    ITK_DIR="/opt/itk/lib/cmake/ITK-5.3"
    INSTALL_PREFIX="${SAMBA_APPS_DIR}/ants"
    SRC="${SRC_ROOT}/ANTs"
    BUILD="${SRC}/build"
    LOG="/tmp/ants_cmake.log"

	# ---- speed: ccache compiler cache ----
	if command -v apt-get >/dev/null 2>&1; then
		export DEBIAN_FRONTEND=noninteractive
		apt-get update
		apt-get install -y --no-install-recommends ccache
		apt-get clean && rm -rf /var/lib/apt/lists/*
	fi
	export CCACHE_DIR="/opt/.ccache"
	mkdir -p "${CCACHE_DIR}"
	ccache --max-size=5G || true
	export CMAKE_C_COMPILER_LAUNCHER=ccache
	export CMAKE_CXX_COMPILER_LAUNCHER=ccache

	# ---------- ensure correct ANTs source/commit ----------
	mkdir -p /opt/src
	cd /opt/src
	if [ ! -d ANTs ]; then
		git clone https://github.com/ANTsX/ANTs.git
	fi
	cd ANTs
	git fetch --all --tags
	# pin to the commit we validated in /tmp debug
	# pin to the commit we validated in /tmp debug (but allow override via env)
	git checkout --detach "${ANTS_REF:-0ea8e53}"


	# ---------- CLEAN OUT ANY SUPERBUILD ARTIFACTS ----------
	rm -rf build ANTS-build ANTS-prefix 2>/dev/null || true
	mkdir -p build
	cd build

	# ---------- CONFIGURE: SUPERBUILD OFF + EXTERNAL ITK ----------
	cmake -G Ninja \
		-DCMAKE_BUILD_TYPE=Release \
		-DCMAKE_INSTALL_PREFIX="${INSTALL_PREFIX}" \
		-DITK_DIR:PATH="${ITK_DIR}" \
		-DANTS_SUPERBUILD=OFF \
		-DBUILD_TESTING=OFF \
		-DBUILD_ALL_ANTS_APPS=OFF \
		..

	# fast sanity: show a few available targets (for future debugging)
	ninja -t targets all 2>/dev/null | head -n 40 || true

	# ---------- build only the core CLIs, with smart parallelism ----------
	# Pick JOBS based on RAM: 4 if >=16GB, 2 if >=8GB, else 1
	if awk '/MemTotal:/ {exit ($2>=16000000)?10:($2>=8000000)?20:0}' /proc/meminfo; then
		JOBS=4
	elif [ "$?" -eq 20 ]; then
		JOBS=2
	else
		JOBS=1
	fi

	WANTED="
		antsRegistration
		antsApplyTransforms
		N4BiasFieldCorrection
		Atropos
		ImageMath
		ResampleImageBySpacing
		ResampleImage
		SmoothImage
		MultiplyImages
		ThresholdImage
		PrintHeader
		ConvertImage
		ConvertImagePixelType
		SetOrigin
		SetSpacing
		ConvertTransformFile
	"

	# collect available target names (strip trailing ':')
	AVAIL="$(ninja -t targets all 2>/dev/null | cut -d: -f1 | sort -u)"

	# resolve wanted tools to actual build targets
	RESOLVED=""
	for tool in $WANTED; do
		if printf '%s\n' "$AVAIL" | grep -qx "Examples/$tool"; then
			RESOLVED="$RESOLVED Examples/$tool"
		elif printf '%s\n' "$AVAIL" | grep -qx "$tool"; then
			RESOLVED="$RESOLVED $tool"
		elif printf '%s\n' "$AVAIL" | grep -qx "l_$tool"; then
			RESOLVED="$RESOLVED l_$tool"
		else
			echo "WARN: no target for '$tool' in this tree; skipping" >&2
		fi
	done

	# build in small batches for speed without blowing RAM
	# (batch size = JOBS; each build gets -j "$JOBS")
	mkdir -p /tmp/ants_logs
	i=0
	batch=""
	for tgt in $RESOLVED; do
		batch="$batch --target $tgt"
		i=$((i+1))
		if [ "$i" -ge "$JOBS" ]; then
					# old:
			# log="/tmp/ants_logs/batch_$RANDOM.log"; : > "$log"
			# new (POSIX-safe):
			log="$(mktemp /tmp/ants_logs/batch_XXXXXX.log)"; : > "$log"

			echo "=== Building batch (j=$JOBS): $batch ==="
			if ! cmake --build . $batch -- -j "$JOBS" >"$log" 2>&1; then
				echo "BUILD FAILED in batch. Last 200 lines:" >&2
				tail -n 200 "$log" >&2
				exit 1
			fi
			i=0
			batch=""
		fi
	done
	# flush any remainder
	if [ -n "$batch" ]; then
		log="$(mktemp /tmp/ants_logs/batch_tail_XXXXXX.log)"; : > "$log"

		echo "=== Building final batch (j=$JOBS): $batch ==="
		if ! cmake --build . $batch -- -j "$JOBS" >"$log" 2>&1; then
			echo "BUILD FAILED in final batch. Last 200 lines:" >&2
			tail -n 200 "$log" >&2
			exit 1
		fi
	fi

	# ---------- INSTALL (or copy from Examples/ if no install rule) ----------
	if ! cmake --install . --prefix "${INSTALL_PREFIX}" ; then
		echo "No install target; copying built binaries to ${INSTALL_PREFIX}/bin"
		mkdir -p "${INSTALL_PREFIX}/bin"
		for t in $WANTED; do
			# common output location for this commit/layout
			if [ -f "Examples/$t" ]; then
				cp -fv "Examples/$t" "${INSTALL_PREFIX}/bin/"
				continue
			fi
			# last resort: ask ninja where the artifact is
			out="$(ninja -t query "$t" 2>/dev/null | awk '/^  outputs:/{print $2; exit}')"
			if [ -n "$out" ] && [ -f "$out" ]; then
				cp -fv "$out" "${INSTALL_PREFIX}/bin/"
			fi
		done
	fi

	# ---------- FINAL SANITY ----------
	if [ ! -x "${INSTALL_PREFIX}/bin/antsRegistration" ]; then
		echo "FATAL: ANTs installation failed â€” ${INSTALL_PREFIX}/bin/antsRegistration not found." >&2
		find "${INSTALL_PREFIX}/bin" -maxdepth 1 -type f -printf '%f\n' | sort | head -n 200 >&2 || true
		exit 1
	fi

	chmod -R a+rX "${INSTALL_PREFIX}"

%test
	set -eu
	[ -x "${SAMBA_APPS_DIR:-/opt/samba}/ants/bin/antsRegistration" ]
	echo "ANTs core tools present."

%runscript
	exec /bin/sh -c "$@"
