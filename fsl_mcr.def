Bootstrap: localimage
From: ants.sif

%labels
	Owner	Robert Anderson
	Stage	fsl_mcr

%environment
	# --- SAMBA-style runtime env (kept consistent with samba.def) ---
	export SAMBA_APPS_DIR=/opt/samba
	export SAMBA_PATH=${SAMBA_APPS_DIR}/SAMBA

	# FSL: at runtime we point FSLDIR to the public link (/opt/samba/fsl)
	# which this stage will make point at the mini tree.
	export FSLDIR=${SAMBA_APPS_DIR}/fsl
	export FSLOUTPUTTYPE=NIFTI_GZ
	export PATH=${SAMBA_PATH}:${FSLDIR}/bin:$PATH

	# MATLAB runtime + exec helpers (R2015b)
	export MATLAB_2015b_PATH=/opt/MATLAB/MATLAB2015b_runtime/v90
	export MCRROOT=${MATLAB_2015b_PATH}
	export LD_LIBRARY_PATH=${MCRROOT}/runtime/glnxa64:${MCRROOT}/bin/glnxa64:${MCRROOT}/sys/os/glnxa64:$LD_LIBRARY_PATH
	export MATLAB_JAVA=${SAMBA_APPS_DIR}/java/jre
	export MATLAB_EXEC_PATH=/opt/samba/matlab_execs_for_SAMBA

	# Perlbrew runtime activation (best-effort)
	export PERLBREW_ROOT=${SAMBA_APPS_DIR}/perl5
	export PATH="$PERLBREW_ROOT/bin:$PATH"
	. "$PERLBREW_ROOT/etc/bashrc" 2>/dev/null || true

%post
	set -eu

	# --- base noninteractive setup ---
	export DEBIAN_FRONTEND=noninteractive
	export TZ=Etc/UTC
	ln -fs /usr/share/zoneinfo/$TZ /etc/localtime
	apt-get update
	apt-get install -y --no-install-recommends tzdata
	dpkg-reconfigure -f noninteractive tzdata

	# --- core packages (match samba.def vibe) ---
	apt-get update && apt-get install -y --no-install-recommends \
		build-essential curl wget unzip bzip2 ca-certificates \
		perl libperl-dev python3 git \
		openjdk-8-jre-headless

	# --- layout roots ---
	SAMBA_APPS_DIR=/opt/samba
	SAMBA_PATH=${SAMBA_APPS_DIR}/SAMBA
	mkdir -p "${SAMBA_APPS_DIR}" /opt/src

	# =====================================================================
	# 1) MATLAB R2015b Runtime (MCR) + Java 8  (EARLY -> fail fast)
	# =====================================================================
	BUILD_ROOT=/opt/build
	ME_DIR=${BUILD_ROOT}/matlab_execs
	CACHE_DIR=${BUILD_ROOT}/matlab_cache
	MATLAB_2015b_PATH=/opt/MATLAB/MATLAB2015b_runtime/v90
	INSTALLER_NAME=MCR_R2015b_glnxa64_installer.zip
	INSTALLER_PATH=${ME_DIR}/${INSTALLER_NAME}
	TEMP_DIR=${ME_DIR}/temp

	mkdir -p "$MATLAB_2015b_PATH" "$ME_DIR" "$TEMP_DIR" "$CACHE_DIR"

	# download with a clean env to avoid any libcurl collisions
	if [ ! -f "${CACHE_DIR}/${INSTALLER_NAME}" ]; then
		env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin \
			wget -O "${INSTALLER_PATH}" \
			"http://ssd.mathworks.com/supportfiles/downloads/R2015b/deployment_files/R2015b/installers/glnxa64/${INSTALLER_NAME}"
		cp -f "${INSTALLER_PATH}" "${CACHE_DIR}/" || true
	else
		cp -f "${CACHE_DIR}/${INSTALLER_NAME}" "${INSTALLER_PATH}"
	fi

	unzip -d "${TEMP_DIR}" "${INSTALLER_PATH}"
	"${TEMP_DIR}/install" -mode silent -agreeToLicense yes -destinationFolder "${MATLAB_2015b_PATH}"
	rm -rf "${TEMP_DIR}"

	# verify a key MCR lib exists (either runtime/ or bin/ layouts)
	if ! ls "${MATLAB_2015b_PATH}"/runtime/glnxa64/libmwmclmcrrt.so* >/dev/null 2>&1 && \
	   ! ls "${MATLAB_2015b_PATH}"/bin/glnxa64/libmwmclmcrrt.so*     >/dev/null 2>&1 ; then
		echo "FATAL: MCR libmwmclmcrrt.so* missing under ${MATLAB_2015b_PATH}" >&2
		exit 1
	fi

	# Java 8 copy (mirror samba.def)
	mkdir -p /opt/samba/java
	cp -a /usr/lib/jvm/java-8-openjdk-amd64/jre /opt/samba/java

	# matlab_execs_for_SAMBA (mirror samba.def)
	if [ ! -d /opt/samba/matlab_execs_for_SAMBA ]; then
		git clone https://github.com/andersonion/matlab_execs_for_SAMBA.git /opt/samba/matlab_execs_for_SAMBA
	fi
	chmod -R a+rX /opt/samba/matlab_execs_for_SAMBA
	ln -sfn /opt/samba/matlab_execs_for_SAMBA /opt/matlab_execs

	# Prefer ld.so to LD_LIBRARY_PATH for MCR at runtime
	cat >/etc/ld.so.conf.d/mcr_v90.conf <<EOF
/opt/MATLAB/MATLAB2015b_runtime/v90/runtime/glnxa64
/opt/MATLAB/MATLAB2015b_runtime/v90/bin/glnxa64
/opt/MATLAB/MATLAB2015b_runtime/v90/sys/os/glnxa64
EOF
	ldconfig

	# =====================================================================
	# 2) Perlbrew + Perl 5.16.3 + cpanm + Carton  (EARLY -> fail fast)
	# =====================================================================
	# --- perlbrew install in a CLEAN env (avoid MCR's libcurl) ---
	PERLBREW_ROOT="/opt/samba/perl5"
	mkdir -p "${PERLBREW_ROOT}"
	# fetch installer without any LD_LIBRARY_PATH or MCR ld paths
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin \
		/usr/bin/curl -fsSL -o /tmp/perlbrew-install.sh https://install.perlbrew.pl
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin \
		bash /tmp/perlbrew-install.sh

	# use perlbrew via absolute path; also keep env clean for the first runs
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin HOME=/root \
		"${PERLBREW_ROOT}/bin/perlbrew" install -n perl-5.16.3
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin HOME=/root \
		"${PERLBREW_ROOT}/bin/perlbrew" install-cpanm

	# activate at login (same as before)
	cat >/etc/profile.d/perlbrew.sh <<'EOF'
export PERLBREW_ROOT=/opt/samba/perl5
if [ -r "$PERLBREW_ROOT/etc/bashrc" ]; then
	. "$PERLBREW_ROOT/etc/bashrc"
fi
EOF
	chmod 644 /etc/profile.d/perlbrew.sh


	# Carton deps for SAMBA repo (optional here; cheap sanity)
	if [ ! -d "${SAMBA_PATH}" ]; then
		git clone https://github.com/andersonion/SAMBA.git "${SAMBA_PATH}"
	fi
	cd "${SAMBA_PATH}"
	if [ -f "cpanfile" ]; then
		CARTON_CMD="carton install"
		"${PERLBREW_ROOT}/bin/perlbrew" exec --with perl-5.16.3 $CARTON_CMD || true
	fi

	# =====================================================================
	# 3) FSL: install full (conda) → harvest mini → link public path (LAST)
	# =====================================================================
	build_fsl_mini() {
		set -eu

		# single source of truth for tool list
		FSL_TOOLS="
			fslmaths
			fdr
			randomise
			design_ttest2
		"
		FSL_HELPERS="
			fslpython
			fsl_sub
		"
		FSL_ALL="$(printf '%s %s' "${FSL_TOOLS}" "${FSL_HELPERS}")"

		FSL_INSTALL_BASE=/opt/samba/.fsl_full
		FSL_MINI_DIR=/opt/samba/.fsl_mini
		FSL_PUBLIC_LINK=/opt/samba/fsl
		FSL_VER=6.0.6

		rm -rf "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"
		mkdir -p "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"

		# --- full conda-based FSL into hidden staging dir ---
		tmp_inst="$(mktemp /tmp/fslinstaller.XXXXXX.py)"
		rm -f "${tmp_inst}"
		env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin \
			curl -fsSL -o "${tmp_inst}" https://fsl.fmrib.ox.ac.uk/fsldownloads/fslinstaller.py
		env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin \
			python3 "${tmp_inst}" \
				-d "${FSL_INSTALL_BASE}/${FSL_VER}" \
				-V "${FSL_VER}" \
				-q --skip_registration --yes
		echo "FSL successfully installed"

		# find a real FSL root that has bin/fslmaths
		FSL_VERSION_DIR="${FSL_INSTALL_BASE}/${FSL_VER}"
		FSL_BIN="$(find "${FSL_VERSION_DIR}" -type f -name fslmaths -path '*/bin/*' -print -quit || true)"
		if [ -z "${FSL_BIN}" ]; then
			echo "FATAL: could not locate fslmaths under ${FSL_VERSION_DIR}" >&2
			exit 1
		fi
		FSL_FULL="$(dirname "$(dirname "${FSL_BIN}")")"  # …/bin → parent

		# fresh mini tree
		mkdir -p "${FSL_MINI_DIR}/bin" "${FSL_MINI_DIR}/lib" "${FSL_MINI_DIR}/etc/fslconf" "${FSL_MINI_DIR}/share/fsl/data"

		# config if present
		[ -d "${FSL_FULL}/etc/fslconf" ] && cp -a "${FSL_FULL}/etc/fslconf/." "${FSL_MINI_DIR}/etc/fslconf/"

		# optional shared data (best-effort)
		if [ -d "${FSL_FULL}/share/fsl/data" ]; then
			cp -a "${FSL_FULL}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
		elif [ -d "${FSL_FULL%/*}/share/fsl/data" ]; then
			cp -a "${FSL_FULL%/*}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
		fi

		# helper: copy tool + its ELF deps
		copy_tool() {
			_tool="$1"
			_path="$(find "${FSL_VERSION_DIR}" -type f -name "${_tool}" -perm -111 -path '*/bin/*' -print -quit 2>/dev/null || true)"
			if [ -z "${_path}" ]; then
				_path="$(find "${FSL_VERSION_DIR}" -type f -name "${_tool}" -perm -111 -print -quit 2>/dev/null || true)"
			fi
			[ -z "${_path}" ] && return 1
			cp -a "${_path}" "${FSL_MINI_DIR}/bin/${_tool}"
			ldd "${_path}" 2>/dev/null | awk '/=> \//{print $3}' | while read -r so; do
				[ -n "${so}" ] && cp -n "${so}" "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
			done
		}

		for t in ${FSL_ALL}; do
			copy_tool "${t}" || echo "WARN: ${t} not found under ${FSL_VERSION_DIR}" >&2
		done

		# include any FSL-private libs if shipped
		[ -d "${FSL_FULL}/lib" ] && cp -a "${FSL_FULL}/lib/"lib*.so* "${FSL_MINI_DIR}/lib/" 2>/dev/null || true

		# backfill *all* lib/*.so* from any nested conda envs/pkgs
		find "${FSL_VERSION_DIR}" -type f -path '*/lib/lib*.so*' -exec cp -n {} "${FSL_MINI_DIR}/lib/" \; 2>/dev/null || true

		# ensure GSL links resolve to latest
		_link_latest () {
			pref="$1"
			cand="$(ls -1 "${FSL_MINI_DIR}/lib/${pref}"* 2>/dev/null | sort -V | tail -1 || true)"
			[ -z "${cand}" ] && return 0
			base="$(basename "${cand}")"
			ln -sfn "${base}" "${FSL_MINI_DIR}/lib/${pref}"
		}
		_link_latest libgslcblas.so.0
		_link_latest libgslcblas.so
		_link_latest libgsl.so.27
		_link_latest libgsl.so

		# strictly required modern GCC libs (conda-provided)
		for _lib in libstdc++.so.6 libgcc_s.so.1 libgomp.so.1 libquadmath.so.0 libgfortran.so.5; do
			src="$(find "${FSL_VERSION_DIR}" -type f -path "*/lib/${_lib}*" -print | head -n1 || true)"
			[ -n "${src}" ] && cp -f "${src}" "${FSL_MINI_DIR}/lib/" || true
		done
		# make sure SONAME link for libstdc++ exists
		if real="$(ls -1 "${FSL_MINI_DIR}/lib/libstdc++.so.6"* 2>/dev/null | sort -V | tail -1)"; then
			ln -sfn "$(basename "$real")" "${FSL_MINI_DIR}/lib/libstdc++.so.6"
		fi

		# diagnostics
		echo "[skinny-fsl] mini bin contains:"
		ls -l "${FSL_MINI_DIR}/bin" || true

		echo "[skinny-fsl] ldd check for fslmaths:"
		ldd "${FSL_MINI_DIR}/bin/fslmaths" 2>/dev/null | awk '/not found/ {print "MISSING:",$0}' || true
		echo "[skinny-fsl] ldd check for fdr:"
		ldd "${FSL_MINI_DIR}/bin/fdr" 2>/dev/null | awk '/not found/ {print "MISSING:",$0}' || true

		# publish: /opt/samba/fsl → mini
		ln -sfn "${FSL_MINI_DIR}" "${FSL_PUBLIC_LINK}"

		# smoke tests (fail build if broken)
		"${FSL_PUBLIC_LINK}/bin/fslmaths" -version >/dev/null 2>&1 || { echo "FATAL: fslmaths failed -version"; exit 1; }
		"${FSL_PUBLIC_LINK}/bin/fdr" -h >/dev/null 2>&1 || { echo "FATAL: fdr failed -h"; exit 1; }
		"${FSL_PUBLIC_LINK}/bin/randomise" -h >/dev/null 2>&1 || { echo "FATAL: randomise failed -h"; exit 1; }
		"${FSL_PUBLIC_LINK}/bin/design_ttest2" -h >/dev/null 2>&1 || { echo "FATAL: design_ttest2 failed -h"; exit 1; }

		# nuke the full conda install to keep image small
		rm -rf "${FSL_INSTALL_BASE}"
		chmod -R a+rX "${FSL_MINI_DIR}"
	}

	# run FSL build LAST
	build_fsl_mini

%runscript
	exec bash
