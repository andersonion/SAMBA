Bootstrap: localimage
From: base.sif

%labels
	App: SAMBA FSL+MCR stage
	Maintainer: you
	Stage: fsl_mcr

%environment
	# container runtime env (evaluate at runtime, not build time)
	export SAMBA_APPS_DIR="${SAMBA_APPS_DIR:-/opt/samba}"
	export FSLROOT="${FSLROOT:-${SAMBA_APPS_DIR}/fsl}"         # public symlink target (will point to mini)
	export FSLDIR="${FSLROOT}"
	export FSLOUTPUTTYPE="${FSLOUTPUTTYPE:-NIFTI_GZ}"
	export PATH="${FSLDIR}/bin:${PATH}"

%post
	set -eu

	# ---- toggles ----
	SKIP_FSL="${SKIP_FSL:-0}"          # 1=skip FSL build entirely
	SKIP_MCR="${SKIP_MCR:-0}"          # 1=skip MATLAB MCR prep

	# ---- base dirs (do not hard-code; keep variable-driven) ----
	SAMBA_APPS_DIR="${SAMBA_APPS_DIR:-/opt/samba}"
	FSLROOT="${FSLROOT:-${SAMBA_APPS_DIR}/fsl}"

	# ---- noninteractive apt and core packages ----
	if command -v apt-get >/dev/null 2>&1; then
		export DEBIAN_FRONTEND=noninteractive
		# never let foreign libcurl from MCR or FSL env bleed into host tools
		LD_LIBRARY_PATH= apt-get update
		LD_LIBRARY_PATH= apt-get install -y --no-install-recommends \
			tzdata ca-certificates gnupg curl wget unzip bzip2 \
			build-essential git cmake ninja-build \
			libfftw3-dev liblapacke-dev zlib1g-dev \
			libjpeg-dev libpng-dev libtiff5-dev \
			libexpat1-dev libxml2-dev libbz2-dev \
			libeigen3-dev bc python3 \
			openjdk-8-jre-headless
		ln -fs /usr/share/zoneinfo/Etc/UTC /etc/localtime
		dpkg-reconfigure -f noninteractive tzdata
	fi

	# ---- create app roots (variable-driven) ----
	mkdir -p "${SAMBA_APPS_DIR}" "${SAMBA_APPS_DIR}/perl5" "${SAMBA_APPS_DIR}/java"

	# ---- stage a clean JRE (some legacy tools look here explicitly) ----
	if [ -d /usr/lib/jvm/java-8-openjdk-amd64/jre ]; then
		cp -a /usr/lib/jvm/java-8-openjdk-amd64/jre "${SAMBA_APPS_DIR}/java"
	fi

	# =====================================================================
	# EARLY, FLAKY PIECES FIRST (so we fail fast)
	# =====================================================================

	# ---- MATLAB MCR (optional; guard if you don’t need it in this stage) ----
	if [ "${SKIP_MCR}" -ne 1 ]; then
		# If you mount /opt/MATLAB/MATLAB2015b_runtime into later stages, nothing to do here.
		# This block is intentionally minimal to avoid libcurl collisions.
		true
	fi

	# =====================================================================
	# (…other stage work you keep here — e.g., perlbrew init, non-FSL runtime bits…)
	# =====================================================================

	# =====================================================================
	# FSL: INSTALL FULL → HARVEST MINI → LINK PUBLIC PATH  (RUNS LAST)
	# =====================================================================
	build_fsl_mini() {
		set -eu

		# Keep all paths variable-driven
		FSL_INSTALL_BASE="${SAMBA_APPS_DIR}/.fsl_full"   # hidden staging for full conda install
		FSL_MINI_DIR="${SAMBA_APPS_DIR}/.fsl_mini"       # hidden mini payload; public link ${FSLROOT} → here
		FSL_VER="${FSL_VER:-6.0.6}"

		# Clean any old staging (do not touch public link yet)
		rm -rf "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"
		mkdir -p "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"

		# Download installer with a *clean* loader env
		tmp_inst="$(mktemp -p /tmp fslinstaller.XXXXXX.py)"
		rm -f "${tmp_inst}"
		LD_LIBRARY_PATH= /usr/bin/curl -fsSL -o "${tmp_inst}" "https://fsl.fmrib.ox.ac.uk/fsldownloads/fslinstaller.py"

		# Non-interactive full install into hidden staging
		# Avoid any pre-set PATH/LD_LIBRARY_PATH to prevent pulling conda shims during build
		(	# subshell to localize env
			unset PATH LD_LIBRARY_PATH || true
			PATH="/usr/sbin:/usr/bin:/sbin:/bin"
			python3 "${tmp_inst}" \
				--dest="${FSL_INSTALL_BASE}/${FSL_VER}" \
				--version="${FSL_VER}" \
				--quiet \
				--skip_registration \
				--yes
		)

		echo "FSL successfully installed"

		# Discover a real FSL root containing bin/fslmaths inside the staged install
		FSL_VERSION_DIR="${FSL_INSTALL_BASE}/${FSL_VER}"
		FSL_BIN="$(find "${FSL_VERSION_DIR}" -type f -name fslmaths -path '*/bin/*' -print -quit || true)"
		if [ -z "${FSL_BIN}" ]; then
			echo "FATAL: could not locate fslmaths under ${FSL_VERSION_DIR}" >&2
			find "${FSL_VERSION_DIR}" -maxdepth 4 -type f -name fslmaths 2>/dev/null | sed 's/^/  /' >&2 || true
			exit 1
		fi
		FSL_FULL="$(dirname "$(dirname "${FSL_BIN}")")"  # …/something/bin → its parent

		# Single source of truth for tools we keep
		# (edit here if SAMBA needs more FSL CLIs later)
		export FSL_TOOLS="
			fslmaths
			fdr
			randomise
			design_ttest2
		"
		export FSL_HELPERS="
			fslpython
			fsl_sub
		"
		export FSL_ALL_TO_COPY="$(printf "%s %s" "${FSL_TOOLS}" "${FSL_HELPERS}")"

		# Build fresh mini tree
		mkdir -p "${FSL_MINI_DIR}/bin" "${FSL_MINI_DIR}/lib" "${FSL_MINI_DIR}/etc/fslconf" "${FSL_MINI_DIR}/share/fsl/data"

		# Minimal config (if present)
		if [ -d "${FSL_FULL}/etc/fslconf" ]; then
			cp -a "${FSL_FULL}/etc/fslconf/." "${FSL_MINI_DIR}/etc/fslconf/"
		fi
		# Optional data (atlases/templates)
		if [ -d "${FSL_FULL}/share/fsl/data" ]; then
			cp -a "${FSL_FULL}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
		elif [ -d "${FSL_FULL%/*}/share/fsl/data" ]; then
			cp -a "${FSL_FULL%/*}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
		fi

		# Helper to copy a tool from anywhere inside staged install and backfill its ELF deps
		copy_tool() {
			_tool="$1"
			_path="$(find "${FSL_VERSION_DIR}" -type f -name "${_tool}" -perm -111 -path '*/bin/*' -print -quit 2>/dev/null || true)"
			if [ -z "${_path}" ]; then
				_path="$(find "${FSL_VERSION_DIR}" -type f -name "${_tool}" -perm -111 -print -quit 2>/dev/null || true)"
			fi
			[ -z "${_path}" ] && return 1
			cp -a "${_path}" "${FSL_MINI_DIR}/bin/${_tool}"
			# backfill linked libs (ignore scripts that aren't ELF)
			ldd "${_path}" 2>/dev/null | awk '/=> \//{print $3}' | while read -r so; do
				[ -n "${so}" ] && cp -n "${so}" "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
			done
			return 0
		}

		for t in ${FSL_ALL_TO_COPY}; do
			if ! copy_tool "${t}"; then
				echo "WARN: ${t} not found under ${FSL_VERSION_DIR}" >&2
			fi
		done

		# Sweep any shared libs living under lib/ anywhere in staged install (conda envs, pkgs, etc.)
		find "${FSL_VERSION_DIR}" -type f -path '*/lib/lib*.so*' -exec cp -n {} "${FSL_MINI_DIR}/lib/" \; 2>/dev/null || true

		# Include FSL-provided libs if present (duplicate-safe)
		if [ -d "${FSL_FULL}/lib" ]; then
			cp -a "${FSL_FULL}/lib/"lib*.so* "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
		fi

		# Ensure GSL soname and generic links point at the newest file copied
		_link_latest () {
			prefix="$1"  # e.g., libgsl.so.27 or libgsl.so
			cand="$(ls -1 "${FSL_MINI_DIR}/lib/${prefix}"* 2>/dev/null | sort -V | tail -1 || true)"
			[ -z "${cand}" ] && return 0
			base="$(basename "${cand}")"
			ln -sfn "${base}" "${FSL_MINI_DIR}/lib/${prefix}"
		}
		_link_latest libgslcblas.so.0
		_link_latest libgslcblas.so
		_link_latest libgsl.so.27
		_link_latest libgsl.so

		# Fix up critical GCC runtime libs (libstdc++ et al) to satisfy GLIBCXX requirements
		_fix_copy_soname () {
			_need="$1"  # libstdc++.so.6, libgcc_s.so.1, etc.
			_real="$(find "${FSL_VERSION_DIR}" -type f -path "*/lib/${_need}*" -exec bash -lc 't="{}"; [ -L "$t" ] && readlink -f "$t" || echo "$t"' \; 2>/dev/null \
			         | grep -E "/lib/${_need}(\.|$)" | head -n1 || true)"
			[ -z "${_real}" ] && return 0
			cp -f "${_real}" "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
			if [ "${_need}" = "libstdc++.so.6" ]; then
				ln -sfn "$(basename "${_real}")" "${FSL_MINI_DIR}/lib/libstdc++.so.6"
			fi
		}
		for _lib in libstdc++.so.6 libgcc_s.so.1 libgomp.so.1 libquadmath.so.0 libgfortran.so.5; do
			_fix_copy_soname "${_lib}"
		done

		# Log what we staged
		echo "[skinny-fsl] staged tool locations:"
		for t in ${FSL_TOOLS}; do
			find "${FSL_VERSION_DIR}" -type f -name "${t}" -print 2>/dev/null | sed "s/^/  ${t}: /" || true
		done
		echo "[skinny-fsl] mini bin contains:"
		ls -l "${FSL_MINI_DIR}/bin" || true

		# Quick dependency check before making public
		ldd "${FSL_MINI_DIR}/bin/fslmaths" 2>/dev/null | awk '/not found/ {print "MISSING:",$0}' || true
		ldd "${FSL_MINI_DIR}/bin/fdr" 2>/dev/null | awk '/not found/ {print "MISSING:",$0}' || true

		# Link public path last
		ln -sfn "${FSL_MINI_DIR}" "${FSLROOT}"

		# Smoke tests with *clean* loader (avoid picking host libs)
		(
			export FSLDIR="${FSLROOT}"
			export PATH="${FSLDIR}/bin:${PATH}"
			export FSLOUTPUTTYPE="${FSLOUTPUTTYPE:-NIFTI_GZ}"
			LD_LIBRARY_PATH="${FSLDIR}/lib" "${FSLDIR}/bin/fslmaths" -version >/dev/null 2>&1
			LD_LIBRARY_PATH="${FSLDIR}/lib" "${FSLDIR}/bin/fdr" -h >/dev/null 2>&1 || true
			LD_LIBRARY_PATH="${FSLDIR}/lib" "${FSLDIR}/bin/randomise" -h >/dev/null 2>&1 || true
			LD_LIBRARY_PATH="${FSLDIR}/lib" "${FSLDIR}/bin/design_ttest2" -h >/dev/null 2>&1 || true
		) || { echo "FATAL: FSL smoke test failed."; exit 1; }

		# Remove the full conda-based staging to keep the image lean
		rm -rf "${FSL_INSTALL_BASE}"
		echo "[skinny-fsl] mini tree at ${FSL_MINI_DIR}"
		ls -l "${FSL_MINI_DIR}/bin" || true
	}

	# ---- call FSL last (or skip) ----
	if [ "${SKIP_FSL}" -eq 0 ]; then
		build_fsl_mini
	else
		echo "SKIP_FSL=1 → skipping FSL-mini build (leaving whatever is present)."
	fi

%runscript
	exec /bin/bash -lc "$@"

%test
	set -eu
	# basic sanity: FSL present and runnable if we did not skip it
	if [ "${SKIP_FSL:-0}" -eq 0 ]; then
		SAMBA_APPS_DIR="${SAMBA_APPS_DIR:-/opt/samba}"
		FSLDIR="${FSLDIR:-${SAMBA_APPS_DIR}/fsl}"
		if [ ! -x "${FSLDIR}/bin/fslmaths" ]; then
			echo "FATAL: fslmaths missing in ${FSLDIR}/bin"
			exit 1
		fi
		LD_LIBRARY_PATH="${FSLDIR}/lib" "${FSLDIR}/bin/fslmaths" -version >/dev/null 2>&1 || {
			echo "FATAL: fslmaths failed -version"; exit 1;
		}
	fi
	echo "OK"
