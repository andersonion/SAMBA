Bootstrap: localimage
From: ants.sif

%labels
	Stage fsl_mcr
	Maintainer SAMBA
	Description "MCR/Java/perlbrew early, skinny FSL last with RPATH fix"

%environment
	# Runtime env: keep it minimal and predictable
	export FSLDIR=/opt/samba/fsl
	export FSLOUTPUTTYPE=${FSLOUTPUTTYPE:-NIFTI_GZ}
	export PATH="${FSLDIR}/bin:${PATH}"

%post
	set -eu

	# ---------- constants & helpers ----------
	SAMBA_APPS_DIR="${SAMBA_APPS_DIR:-/opt/samba}"
	MCR_ROOT="/opt/MATLAB/MATLAB2015b_runtime/v90"
	SYSTEM_PATH="/usr/sbin:/usr/bin:/sbin:/bin"
	SYSTEM_LDLIB="/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu"

	# small helper: run a command in a scrubbed env (no LD_LIBRARY_PATH leakage)
	_run_clean () {
		# usage: _run_clean CMD [args...]
		env -i PATH="${SYSTEM_PATH}" LD_LIBRARY_PATH="${SYSTEM_LDLIB}" "$@"
	}

	# another helper: strict curl that ignores any foreign libcurl on the image
	_curl_clean () {
		# usage: _curl_clean -fsSL -o /tmp/file URL
		env -i PATH="${SYSTEM_PATH}" LD_LIBRARY_PATH="${SYSTEM_LDLIB}" /usr/bin/curl "$@"
	}

	# ---------- base dirs ----------
	mkdir -p "${SAMBA_APPS_DIR}" "${SAMBA_APPS_DIR}/perl5"

	# =====================================================================
	# EARLY PARTS (fail sooner; keep FSL for last)
	# =====================================================================

	# ---- MATLAB MCR presence check (no mutation) ----
	if [ -d "${MCR_ROOT}/runtime/glnxa64" ]; then
		echo "[mcr] found: ${MCR_ROOT}"
	else
		echo "[mcr] not found (that’s OK — nothing to do here)."
	fi

	# install JRE8 if the base doesn't have it
	if [ ! -d /usr/lib/jvm/java-8-openjdk-amd64/jre ]; then
		apt-get update
		apt-get install -y --no-install-recommends openjdk-8-jre-headless
		apt-get clean
		rm -rf /var/lib/apt/lists/*
	fi

	# now copy the JRE into the SAMBA tree (as you already do)
	mkdir -p "${SAMBA_APPS_DIR}/java"
	cp -a /usr/lib/jvm/java-8-openjdk-amd64/jre "${SAMBA_APPS_DIR}/java"
	

	# ---- matlab_execs_for_SAMBA (read-only checkout) ----
	if [ ! -d "${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA" ]; then
		git clone https://github.com/andersonion/matlab_execs_for_SAMBA.git \
			"${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA"
	fi
	chmod -R a+rX "${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA"
	ln -sfn "${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA" /opt/matlab_execs

	# ---- ldconfig after MCR/execs (safe even if nothing changed) ----
	ldconfig || true

	# ---- perlbrew (sandboxed curl, but preserve HOME/PERLBREW_ROOT) ----
	export PERLBREW_ROOT="${SAMBA_APPS_DIR}/perl5"
	mkdir -p "${PERLBREW_ROOT}"

	# fetch installer with clean lib paths (avoid MCR's libcurl)
	env -i PATH="${SYSTEM_PATH}" LD_LIBRARY_PATH="${SYSTEM_LDLIB}" \
		/usr/bin/curl -fsSL -o /tmp/perlbrew-install.sh https://install.perlbrew.pl

	# run installer with a minimal, but valid, env
	env -i HOME="${PERLBREW_ROOT}" PERLBREW_ROOT="${PERLBREW_ROOT}" \
		PATH="${SYSTEM_PATH}" LD_LIBRARY_PATH="${SYSTEM_LDLIB}" \
		bash /tmp/perlbrew-install.sh -f

	# make perlbrew available to the remainder of this %post
	export PATH="${PERLBREW_ROOT}/bin:${PATH}"

	# (optional) install a specific perl without leaking MCR libs
	# env -i HOME="${PERLBREW_ROOT}" PERLBREW_ROOT="${PERLBREW_ROOT}" \
	# 	PATH="${PERLBREW_ROOT}/bin:${SYSTEM_PATH}" LD_LIBRARY_PATH="${SYSTEM_LDLIB}" \
	# 	perlbrew install -n perl-5.16.3


	# =====================================================================
	# FSL: INSTALL FULL → HARVEST SKINNY → RPATH FIX → LINK → CLEAN
	# =====================================================================
	build_fsl_mini() {
		set -eu

		# versions/paths
		FSL_VER="6.0.6"
		FSL_INSTALL_BASE="${SAMBA_APPS_DIR}/.fsl_full"   # temp full install
		FSL_MINI_DIR="${SAMBA_APPS_DIR}/.fsl_mini"      # final skinny tree (real dir)
		FSLROOT="${SAMBA_APPS_DIR}/fsl"                 # public symlink target

		# ensure tools available for fixups
		apt-get update
		apt-get install -y --no-install-recommends patchelf
		apt-get clean
		rm -rf /var/lib/apt/lists/*

		# clean prior staging
		rm -rf "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"
		mkdir -p "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"

		# fetch installer with sanitized curl
		tmp_inst="$(mktemp -p /tmp fslinstaller.XXXXXX.py)"
		rm -f "${tmp_inst}"
		_curl_clean -fsSL -o "${tmp_inst}" https://fsl.fmrib.ox.ac.uk/fsldownloads/fslinstaller.py

		# correct CLI is -V/--fslversion (not --version)
		_run_clean python3 "${tmp_inst}" \
			--dest="${FSL_INSTALL_BASE}/${FSL_VER}" \
			-V "${FSL_VER}" \
			--yes --quiet --skip_registration

		echo "[fsl] full installed at ${FSL_INSTALL_BASE}/${FSL_VER}"

		# locate a canonical bin root (one that has fslmaths)
		FSL_BIN="$(find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -name fslmaths -path '*/bin/*' -print -quit || true)"
		if [ -z "${FSL_BIN}" ]; then
			echo "FATAL: could not find fslmaths under ${FSL_INSTALL_BASE}/${FSL_VER}" >&2
			exit 1
		fi
		FSL_FULL="$(dirname "$(dirname "${FSL_BIN}")")"   # …/bin → parent

		# single source of truth: the tools you actually need
		FSL_TOOLS="
			fslmaths
			fdr
			randomise
			design_ttest2
		"
		# helpers frequently required by those tools
		FSL_HELPERS="
			fslpython
			fsl_sub
		"
		FSL_ALL_TO_COPY="$(printf "%s %s" "${FSL_TOOLS}" "${FSL_HELPERS}")"

		# create minimal tree
		mkdir -p "${FSL_MINI_DIR}/bin" "${FSL_MINI_DIR}/lib" \
		         "${FSL_MINI_DIR}/etc/fslconf" "${FSL_MINI_DIR}/share/fsl/data"

		# copy config (if present)
		if [ -d "${FSL_FULL}/etc/fslconf" ]; then
			cp -a "${FSL_FULL}/etc/fslconf/." "${FSL_MINI_DIR}/etc/fslconf/"
		fi

		# optional data (atlas/templates) — copy if present
		if [ -d "${FSL_FULL}/share/fsl/data" ]; then
			cp -a "${FSL_FULL}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
		elif [ -d "${FSL_FULL%/*}/share/fsl/data" ]; then
			cp -a "${FSL_FULL%/*}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
		fi

		# helper to copy a tool and its linked libs
		copy_tool () {
			_tool="$1"
			_path="$(find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -name "${_tool}" -perm -111 -path '*/bin/*' -print -quit 2>/dev/null || true)"
			if [ -z "${_path}" ]; then
				_path="$(find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -name "${_tool}" -perm -111 -print -quit 2>/dev/null || true)"
			fi
			if [ -n "${_path}" ]; then
				cp -a "${_path}" "${FSL_MINI_DIR}/bin/${_tool}"
				# gather shared libs (ignore scripts)
				ldd "${_path}" 2>/dev/null | awk '/=> \//{print $3}' | while read -r so; do
					[ -n "${so}" ] && cp -n "${so}" "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
				done
				return 0
			else
				return 1
			fi
		}

		for t in ${FSL_ALL_TO_COPY}; do
			if ! copy_tool "${t}"; then
				echo "WARN: ${t} not found in full install." >&2
			fi
		done

		# include any FSL private libs if present
		if [ -d "${FSL_FULL}/lib" ]; then
			cp -a "${FSL_FULL}/lib/"lib*.so* "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
		fi

		# sweep any libs living under lib/ anywhere in the staged install (conda env, pkgs, etc)
		find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -path '*/lib/lib*.so*' \
			-exec cp -n {} "${FSL_MINI_DIR}/lib/" \; 2>/dev/null || true

		# ----- backfill critical toolchain libs (GLIBCXX, libgcc, gfortran, BLAS/LAPACK, GSL) -----
		# prefer the newest libstdc++ we can find in the staged tree
		for cand in \
			"$(find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -name 'libstdc++.so.6.*' 2>/dev/null | sort -V | tail -1)" \
			"/usr/lib/x86_64-linux-gnu/libstdc++.so.6"
		do
			[ -n "${cand}" ] && [ -f "${cand}" ] && cp -f "${cand}" "${FSL_MINI_DIR}/lib/" && break || true
		done
		# canonical link
		if ls "${FSL_MINI_DIR}/lib/libstdc++.so.6."* >/dev/null 2>&1; then
			best="$(ls -1 "${FSL_MINI_DIR}/lib/libstdc++.so.6."* | sort -V | tail -1)"
			ln -sfn "$(basename "${best}")" "${FSL_MINI_DIR}/lib/libstdc++.so.6"
		fi

		# libgcc_s, libgomp, libquadmath, libgfortran
		for need in libgcc_s.so.1 libgomp.so.1 libquadmath.so.0 libgfortran.so.5; do
			src="$(find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -name "${need}*" | sort -V | tail -1 || true)"
			if [ -n "${src}" ]; then
				cp -n "${src}" "${FSL_MINI_DIR}/lib/" || true
			elif [ -f "/usr/lib/x86_64-linux-gnu/${need}" ]; then
				cp -n "/usr/lib/x86_64-linux-gnu/${need}" "${FSL_MINI_DIR}/lib/" || true
			fi
			# patch ELF soname symlink if versioned file exists
			if ls "${FSL_MINI_DIR}/lib/${need}."* >/dev/null 2>&1; then
				best="$(ls -1 "${FSL_MINI_DIR}/lib/${need}."* | sort -V | tail -1)"
				ln -sfn "$(basename "${best}")" "${FSL_MINI_DIR}/lib/${need%.*}"
			fi
		done

		# BLAS/LAPACK (libblas.so.3, liblapack.so.3)
		for need in libblas.so.3 liblapack.so.3; do
			src="$(find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -name "${need}*" | sort -V | tail -1 || true)"
			if [ -n "${src}" ]; then
				cp -n "${src}" "${FSL_MINI_DIR}/lib/" || true
			elif [ -f "/usr/lib/x86_64-linux-gnu/${need}" ]; then
				cp -n "/usr/lib/x86_64-linux-gnu/${need}" "${FSL_MINI_DIR}/lib/" || true
			fi
		done

		# GSL (libgsl, libgslcblas) — create both versioned and unversioned symlinks
		for base in libgslcblas.so libgsl.so; do
			src="$(find "${FSL_INSTALL_BASE}/${FSL_VER}" -type f -name "${base}*" | sort -V | tail -1 || true)"
			if [ -n "${src}" ]; then
				cp -n "${src}" "${FSL_MINI_DIR}/lib/" || true
			elif [ -f "/usr/lib/x86_64-linux-gnu/${base}" ]; then
				cp -n "/usr/lib/x86_64-linux-gnu/${base}" "${FSL_MINI_DIR}/lib/" || true
			fi
			# fix soname links if we have versioned copies
			if ls "${FSL_MINI_DIR}/lib/${base}."* >/dev/null 2>&1; then
				best="$(ls -1 "${FSL_MINI_DIR}/lib/${base}."* | sort -V | tail -1)"
				ln -sfn "$(basename "${best}")" "${FSL_MINI_DIR}/lib/${base}"
			fi
		done

		# ----- Fix #2: embed RPATH → $ORIGIN/../lib and verify under scrubbed env -----
		if ! command -v patchelf >/dev/null 2>&1; then
			echo "FATAL: patchelf not found; cannot RPATH-fix skinny FSL." >&2
			exit 1
		fi
		for _t in ${FSL_TOOLS}; do
			_b="${FSL_MINI_DIR}/bin/${_t}"
			[ -x "${_b}" ] || { echo "FATAL: missing ${_b}"; exit 1; }
			patchelf --set-rpath '$ORIGIN/../lib' "${_b}" || {
				echo "FATAL: set-rpath failed for ${_b}" >&2; exit 1; }
			patchelf --remove-needed libomp.so "${_b}" 2>/dev/null || true
		done

		# quick triage view
		echo "[skinny-fsl] mini bin contains:"
		ls -l "${FSL_MINI_DIR}/bin" || true

		echo "[skinny-fsl] ldd check for fdr:"
		ldd "${FSL_MINI_DIR}/bin/fdr" || true

		# run scrubbed-env probes
		_run_clean "${FSL_MINI_DIR}/bin/fslmaths" -version || {
			echo "FATAL: fslmaths failed -version under scrubbed env." >&2
			ldd "${FSL_MINI_DIR}/bin/fslmaths" | awk '/not found/ {print "MISSING:",$0}' >&2 || true
			exit 1
		}
		# scrubbed self-test of CLI entry points
		for probe in fdr randomise design_ttest2; do
			_run_clean "${FSL_MINI_DIR}/bin/${probe}" -h || {
				echo "FATAL: ${probe} failed -h under scrubbed env." >&2
				ldd "${FSL_MINI_DIR}/bin/${probe}" | awk '/not found/ {print "MISSING:",$0}' >&2 || true
				exit 1
			}
		done


		# link public path and clean full tree
		ln -sfn "${FSL_MINI_DIR}" "${FSLROOT}"
		rm -rf "${FSL_INSTALL_BASE}"

		echo "[skinny-fsl] OK — linked ${FSLROOT} -> ${FSL_MINI_DIR}"
	}

	# run FSL build last
	build_fsl_mini

%test
	# keep this light but meaningful; honors "fail early"
	if ! /bin/sh -lc '[ -x /opt/samba/fsl/bin/fslmaths ]'; then
		echo "FATAL: fslmaths missing"; exit 1
	fi
	# scrubbed env check (ensures our RPATH fix truly works at runtime)
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin /opt/samba/fsl/bin/fslmaths -version >/dev/null 2>&1 || {
		echo "FATAL: fslmaths -version failed under scrubbed env"; exit 1; }
	echo "fsl_mcr stage: OK"
