Bootstrap: localimage
From: ants.sif

%labels
	App: SAMBA FSL+MCR stage
	Stage: fsl_mcr

%environment
	# --- runtime env (simple; keep PATH lean) ---
	export SAMBA_APPS_DIR=/opt/samba
	export FSLDIR="${SAMBA_APPS_DIR}/fsl"
	export FSLOUTPUTTYPE=${FSLOUTPUTTYPE:-NIFTI_GZ}
	export PATH="${FSLDIR}/bin:${PATH}"
	# matlab_execs helper if present
	if [ -d "${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA" ]; then
		export PATH="${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA:${PATH}"
	fi

%post
	set -eu

	# ---- constants ----
	SAMBA_APPS_DIR="${SAMBA_APPS_DIR:-/opt/samba}"
	MCR_ROOT="/opt/MATLAB/MATLAB2015b_runtime/v90"		# expected from previous stage or host bind
	JAVA_SYS_JRE="/usr/lib/jvm/java-8-openjdk-amd64/jre"
	SYS_LD="/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu"

	export DEBIAN_FRONTEND=noninteractive

	# ---- base OS deps (no NeuroDebian) ----
	apt-get update
	apt-get install -y --no-install-recommends \
		tzdata ca-certificates gnupg curl wget unzip bzip2 \
		build-essential git cmake ninja-build \
		openjdk-8-jre-headless \
		libfftw3-dev liblapacke-dev zlib1g-dev \
		libjpeg-dev libpng-dev libtiff5-dev \
		libexpat1-dev libxml2-dev libbz2-dev \
		libeigen3-dev bc perl libperl-dev python3 ccache
	ln -fs /usr/share/zoneinfo/Etc/UTC /etc/localtime
	dpkg-reconfigure -f noninteractive tzdata

	# =====================================================================
	# EARLY PIECES (MCR / Java / matlab_execs) — BEFORE perlbrew and FSL
	# =====================================================================

	# --- MATLAB MCR: if present, verify a couple of key libs (no global ld yet) ---
	if [ -d "${MCR_ROOT}/runtime/glnxa64" ]; then
		ls "${MCR_ROOT}/runtime/glnxa64/libmwmclmcrrt.so" \
		   "${MCR_ROOT}/runtime/glnxa64/libmwmclmcrrt.so.9.0" >/dev/null 2>&1 || true
	fi

	# --- Java runtime copy (SAMBA expects a fixed path) ---
	mkdir -p "${SAMBA_APPS_DIR}/java"
	if [ -d "${JAVA_SYS_JRE}" ]; then
		cp -a "${JAVA_SYS_JRE}" "${SAMBA_APPS_DIR}/java"
	fi

	# --- matlab_execs helper scripts ---
	if [ ! -d "${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA" ]; then
		git clone https://github.com/andersonion/matlab_execs_for_SAMBA.git \
			"${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA"
		chmod -R a+rX "${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA"
	fi
	ln -sfn "${SAMBA_APPS_DIR}/matlab_execs_for_SAMBA" /opt/matlab_execs || true

	# --- (DEFER adding MCR to global loader until AFTER all network work) ---
	# If your older image wrote /etc/ld.so.conf.d/mcr_v90.conf earlier, we’ll
	# temporarily take it out so system curl won’t bind MCR’s libcurl.
	RESTORE_MCR=0
	if [ -f /etc/ld.so.conf.d/mcr_v90.conf ]; then
		mv /etc/ld.so.conf.d/mcr_v90.conf /etc/ld.so.conf.d/.mcr_v90.conf.off
		ldconfig
		RESTORE_MCR=1
	fi

	# =====================================================================
	# perlbrew bootstrap (clean environment; immune to MCR libcurl)
	# =====================================================================
	PERLBREW_ROOT="${SAMBA_APPS_DIR}/perl5"
	mkdir -p "${PERLBREW_ROOT}"

	# Fetch installer with a squeaky-clean env and explicit system LDs
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin LD_LIBRARY_PATH="${SYS_LD}" \
		/usr/bin/curl -fsSL -o /tmp/perlbrew-install.sh https://install.perlbrew.pl

	# Install perlbrew
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin LD_LIBRARY_PATH="${SYS_LD}" \
		bash /tmp/perlbrew-install.sh

	# Install perl 5.16.3 and cpanm (non-interactive)
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin HOME=/root LD_LIBRARY_PATH="${SYS_LD}" \
		"${PERLBREW_ROOT}/bin/perlbrew" install -n perl-5.16.3
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin HOME=/root LD_LIBRARY_PATH="${SYS_LD}" \
		"${PERLBREW_ROOT}/bin/perlbrew" install-cpanm

	# Activate perlbrew at shell init
	cat >/etc/profile.d/perlbrew.sh <<'EOF'
export PERLBREW_ROOT=/opt/samba/perl5
if [ -r "$PERLBREW_ROOT/etc/bashrc" ]; then
	. "$PERLBREW_ROOT/etc/bashrc"
fi
EOF
	chmod 644 /etc/profile.d/perlbrew.sh

	# =====================================================================
	# FSL: INSTALL FULL → HARVEST MINI → LINK PUBLIC PATH  (RUNS LAST)
	# =====================================================================

	# params
	FSL_VER="6.0.6"
	FSL_INSTALL_BASE="${SAMBA_APPS_DIR}/.fsl_full"
	FSL_VERSION_DIR="${FSL_INSTALL_BASE}/${FSL_VER}"
	FSL_MINI_DIR="${SAMBA_APPS_DIR}/.fsl_mini"
	FSLROOT="${SAMBA_APPS_DIR}/fsl"

	# tools list (single source of truth)
	FSL_TOOLS="
		fslmaths
		fdr
		randomise
		design_ttest2
	"
	FSL_HELPERS="
		fslpython
		fsl_sub
	"
	FSL_ALL_TO_COPY="$(printf "%s %s" "${FSL_TOOLS}" "${FSL_HELPERS}")"

	# clean any previous attempts
	rm -rf "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"
	mkdir -p "${FSL_INSTALL_BASE}" "${FSL_MINI_DIR}"

	# fetch the official installer as a one-shot file (clean env; system libs)
	tmp_inst="$(mktemp -p /tmp fslinstaller.XXXXXX.py)"
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin LD_LIBRARY_PATH="${SYS_LD}" \
		/usr/bin/curl -fsSL -o "${tmp_inst}" https://fsl.fmrib.ox.ac.uk/fsldownloads/fslinstaller.py

	# Run installer (quiet, no registration, auto-yes). Note: new flags use --fslversion
	env -i PATH=/usr/sbin:/usr/bin:/sbin:/bin HOME=/root LD_LIBRARY_PATH="${SYS_LD}" \
		python3 "${tmp_inst}" \
			--dest="${FSL_VERSION_DIR}" \
			--fslversion="${FSL_VER}" \
			--quiet --skip_registration --yes
	rm -f "${tmp_inst}"

	# find a real FSL root that contains bin/fslmaths
	FSL_BIN="$(find "${FSL_VERSION_DIR}" -type f -name fslmaths -path '*/bin/*' -print -quit || true)"
	if [ -z "${FSL_BIN}" ]; then
		echo "FATAL: could not locate fslmaths under ${FSL_VERSION_DIR}" >&2
		exit 1
	fi
	FSL_FULL="$(dirname "$(dirname "${FSL_BIN}")")"

	# build the mini tree
	mkdir -p "${FSL_MINI_DIR}/bin" "${FSL_MINI_DIR}/lib" "${FSL_MINI_DIR}/etc/fslconf" "${FSL_MINI_DIR}/share/fsl/data"

	# minimal config
	if [ -d "${FSL_FULL}/etc/fslconf" ]; then
		cp -a "${FSL_FULL}/etc/fslconf/." "${FSL_MINI_DIR}/etc/fslconf/"
	fi

	# optional data (copy only if present)
	if [ -d "${FSL_FULL}/share/fsl/data" ]; then
		cp -a "${FSL_FULL}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
	elif [ -d "${FSL_FULL%/*}/share/fsl/data" ]; then
		cp -a "${FSL_FULL%/*}/share/fsl/data/." "${FSL_MINI_DIR}/share/fsl/data/" || true
	fi

	# helper to copy a tool and backfill its linked libs
	copy_tool() {
		_tool="$1"
		_path="$(find "${FSL_VERSION_DIR}" -type f -name "${_tool}" -perm -111 -path '*/bin/*' -print -quit 2>/dev/null || true)"
		if [ -z "${_path}" ]; then
			_path="$(find "${FSL_VERSION_DIR}" -type f -name "${_tool}" -perm -111 -print -quit 2>/dev/null || true)"
		fi
		[ -z "${_path}" ] && return 1
		cp -a "${_path}" "${FSL_MINI_DIR}/bin/${_tool}"
		ldd "${_path}" 2>/dev/null | awk '/=> \//{print $3}' | while read -r so; do
			[ -n "${so}" ] && cp -n "${so}" "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
		done
		return 0
	}

	for t in ${FSL_ALL_TO_COPY}; do
		copy_tool "${t}" || echo "WARN: ${t} not found under ${FSL_VERSION_DIR}" >&2
	done

	# include any FSL-provided libs if present
	if [ -d "${FSL_FULL}/lib" ]; then
		cp -a "${FSL_FULL}/lib/"lib*.so* "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
	fi

	# sweep other shared libs under the staged env (conda pkgs), non-destructive
	find "${FSL_VERSION_DIR}" -type f -path '*/lib/lib*.so*' -exec cp -n {} "${FSL_MINI_DIR}/lib/" \; 2>/dev/null || true

	# ensure expected lib aliases/symlinks exist (gsl, blas/lapack, stdc++)
	_link_latest () {
		prefix="$1"
		cand="$(ls -1 "${FSL_MINI_DIR}/lib/${prefix}"* 2>/dev/null | sort -V | tail -1 || true)"
		[ -z "${cand}" ] && return 0
		ln -sfn "$(basename "${cand}")" "${FSL_MINI_DIR}/lib/${prefix}"
	}
	_link_latest libgslcblas.so.0
	_link_latest libgslcblas.so
	_link_latest libgsl.so.27
	_link_latest libgsl.so

	# copy modern libstdc++ & friends if present in the staged tree
	for _lib in libstdc++.so.6 libgcc_s.so.1 libgomp.so.1 libquadmath.so.0 libgfortran.so.5; do
		real="$(find "${FSL_VERSION_DIR}" -type f -path "*/lib/${_lib}*" -print -quit 2>/dev/null || true)"
		[ -n "${real}" ] && cp -f "${real}" "${FSL_MINI_DIR}/lib/" 2>/dev/null || true
	done
	# ensure libstdc++.so.6 points to a real file we just copied
	if ls "${FSL_MINI_DIR}/lib"/libstdc++.so.6* >/dev/null 2>&1; then
		target="$(ls -1 "${FSL_MINI_DIR}/lib"/libstdc++.so.6* | sort -V | tail -1)"
		ln -sfn "$(basename "${target}")" "${FSL_MINI_DIR}/lib/libstdc++.so.6"
	fi

	# diagnostic: show staged locations and mini contents
	echo "[skinny-fsl] staged tool locations:"
	for t in ${FSL_TOOLS}; do
		find "${FSL_VERSION_DIR}" -type f -name "${t}" -print 2>/dev/null | sed "s/^/  ${t}: /" || true
	done
	echo "[skinny-fsl] mini bin contains:"
	ls -l "${FSL_MINI_DIR}/bin" || true

	# final link: public FSL path points at mini
	ln -sfn "${FSL_MINI_DIR}" "${FSLROOT}"

	# smoke tests using a clean env + mini’s lib dir first
	_run_clean () {
		env -i PATH="${FSLROOT}/bin:/usr/sbin:/usr/bin:/sbin:/bin" \
			LD_LIBRARY_PATH="${FSLROOT}/lib:${SYS_LD}" \
			HOME=/root "$@"
	}
	_run_clean "${FSLROOT}/bin/fslmaths" -version >/dev/null 2>&1 || { echo "FATAL: fslmaths failed -version"; exit 1; }
	_run_clean "${FSLROOT}/bin/fdr" -h >/dev/null 2>&1 || { echo "FATAL: fdr failed to run"; exit 1; }
	_run_clean "${FSLROOT}/bin/randomise" -h >/dev/null 2>&1 || { echo "FATAL: randomise failed to run"; exit 1; }
	_run_clean "${FSLROOT}/bin/design_ttest2" -h >/dev/null 2>&1 || { echo "FATAL: design_ttest2 failed to run"; exit 1; }

	# remove the heavy full install once mini passes
	rm -rf "${FSL_INSTALL_BASE}"

	# =====================================================================
	# Restore MCR loader last (optional global enable), then ldconfig
	# =====================================================================
	if [ "${RESTORE_MCR}" -eq 1 ]; then
		mv /etc/ld.so.conf.d/.mcr_v90.conf.off /etc/ld.so.conf.d/mcr_v90.conf
	fi
	ldconfig

	# final perms pass
	chmod -R a+rX "${SAMBA_APPS_DIR}"

%runscript
	exec /bin/bash -l "$@"

%test
	# Quick runtime checks in minimal env
	export FSLDIR=/opt/samba/fsl
	env -i PATH="$FSLDIR/bin:/usr/sbin:/usr/bin:/sbin:/bin" \
		LD_LIBRARY_PATH="$FSLDIR/lib:/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu" \
		HOME=/root "$FSLDIR/bin/fslmaths" -version >/dev/null
